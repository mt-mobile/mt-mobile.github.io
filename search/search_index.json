{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":""},{"location":"#what-is-cross-platform-mobile-app-development","title":"What is Cross-Platform Mobile App Development?","text":"<p>Cross-platform mobile app development refers to the process of building mobile applications that can run on multiple mobile operating systems. Instead of writing distinct codebases for different platforms, developers write a single codebase that can be deployed across multiple platforms.</p> <p>The primary goal is to enable code reuse while maintaining high performance and native-like user experience.</p>"},{"location":"#architectural-considerations","title":"Architectural Considerations","text":"<p>When opting for cross-platform development, architectural decisions become even more crucial. Choosing an appropriate design pattern, such as <code>MVC</code> (Model-View-Controller) or <code>MVVM</code> (Model-View-ViewModel), can significantly impact the maintainability and scalability of your app.</p> <p>Many of the frameworks come with their architectural patterns, like React Native with its component-based architecture, which aligns well with the functional programming paradigm.</p>"},{"location":"#key-technologies-in-cross-platform-development","title":"Key Technologies in Cross-Platform Development","text":"<ol> <li> <p>React Native: As previously discussed, React Native is an open-source framework developed by Facebook, allowing developers to use React and JavaScript to build native-like apps.</p> </li> <li> <p>Flutter: Developed by Google, Flutter is another popular framework that uses the Dart language. Flutter is known for its rich set of fully customizable widgets that allow you to create complex UIs.</p> </li> <li> <p>Xamarin: Developed by Microsoft, Xamarin uses the .NET framework and allows developers to use C# for building mobile apps. It offers robust type-checking and the ability to use native APIs.</p> </li> <li> <p>PhoneGap: Also known as Apache Cordova, PhoneGap is a mobile application development framework that allows developers to use HTML5, CSS3, and JavaScript to build native applications.</p> </li> <li> <p>Ionic: Built on top of Angular, Ionic allows for the development of apps using web technologies. It leans more towards the web end of the spectrum, relying on web views for rendering.</p> </li> </ol>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Mastering React Native By Cybellium Ltd</li> <li>techicons.dev</li> </ul>"},{"location":"#books","title":"Books","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/","title":"Why react-native-dotenv is Incompatible with Expo Router","text":"","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#why-react-native-dotenv-is-incompatible-with-expo-router","title":"Why <code>react-native-dotenv</code> is Incompatible with Expo Router","text":"","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#introduction","title":"Introduction","text":"<p>When building React Native apps with Expo, developers often use libraries like <code>react-native-dotenv</code> to manage environment variables. However, if you're using Expo Router, a file-based routing solution introduced in <code>Expo SDK 49+</code>, you may encounter issues where your app fails to load routes (e.g., <code>app/index.tsx</code>) and reverts to the default \"Welcome to Expo\" screen. This blog post explains why <code>react-native-dotenv</code> is incompatible with Expo Router, the technical reasons behind it, and recommended alternatives for managing environment variables in Expo projects.</p>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#the-issue-welcome-to-expo-screen-after-adding-react-native-dotenv","title":"The Issue: \"Welcome to Expo\" Screen After Adding <code>react-native-dotenv</code>","text":"<p>If you've scaffolded an Expo project with <code>npx create-expo-app@latest</code> and added <code>react-native-dotenv</code>, you might notice that your app stops rendering your routes (e.g., <code>app/index.tsx</code>) and instead displays the \"Welcome to Expo\" screen with a prompt to create <code>app/index.jsx</code>. This issue arises specifically after adding the <code>react-native-dotenv</code> Babel plugin to <code>babel.config.js</code>. For example:</p> <pre><code>// babel.config.js\nmodule.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\"babel-preset-expo\"],\n    plugins: [\n      [\n        \"module:react-native-dotenv\",\n        {\n          moduleName: \"@env\",\n          path: \".env\",\n          blocklist: null,\n          allowlist: null,\n          safe: false,\n          allowUndefined: true,\n        },\n      ],\n    ],\n  };\n};\n</code></pre> <p>Despite having a valid <code>app/index.tsx</code> file and a correctly configured <code>.env</code> file, the app fails to recognize the entry point, indicating a deeper issue with how <code>react-native-dotenv</code> interacts with Expo Router.</p>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#why-react-native-dotenv-breaks-expo-router","title":"Why <code>react-native-dotenv</code> Breaks Expo Router","text":"<p>The incompatibility stems from how <code>react-native-dotenv</code> processes environment variables and how Expo Router relies on specific environment variables for its routing mechanism.</p>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#technical-reasons-for-incompatibility","title":"Technical Reasons for Incompatibility","text":"<p>1. Babel Plugin Interference:</p> <ul> <li> <p><code>react-native-dotenv</code> uses a Babel plugin (<code>module:react-native-dotenv</code>) to inline environment variables from your <code>.env</code> file into the JavaScript bundle during the build process.</p> </li> <li> <p>This plugin aggressively replaces all references to <code>process.env</code> with static values, including internal variables used by Expo Router, such as <code>process.env.EXPO_ROUTER_APP_ROOT</code>.</p> </li> <li> <p>Expo Router depends on <code>EXPO_ROUTER_APP_ROOT</code> to locate the <code>app/</code> directory and resolve routes (e.g., <code>app/index.tsx</code>). When <code>react-native-dotenv</code> overwrites this variable, Expo Router fails to find the routing context, causing the app to fall back to the default \"Welcome to Expo\" screen.</p> </li> </ul> <p>2. Order of Babel Transformations:</p> <ul> <li> <p>The <code>react-native-dotenv</code> plugin runs before <code>babel-preset-expo</code> in the Babel transformation pipeline. This means it processes <code>process.env</code> references before Expo's own transformations, which are critical for Expo Router's file-based routing.</p> </li> <li> <p>As a result, Expo Router's <code>require.context</code> (used to dynamically load routes from the <code>app/</code> directory) fails because the necessary environment variables are no longer available.</p> </li> </ul> <p>3. Lack of Maintenance:</p> <ul> <li> <p><code>react-native-dotenv</code> has not been actively maintained (last significant update around 2023), making it less compatible with newer Expo SDKs (e.g., SDK 51). This lack of updates exacerbates conflicts with modern Expo features like Expo Router.</p> </li> <li> <p>Community reports (e.g., GitHub issues expo/expo#28933 and goatandsheep/react-native-dotenv#501) confirm that the library's Babel plugin disrupts Expo Router's environment variable handling.</p> </li> </ul>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#symptoms-of-the-issue","title":"Symptoms of the Issue","text":"<ul> <li>After adding <code>react-native-dotenv</code>, running <code>npx expo start</code> results in the \"Welcome to Expo\" screen.</li> <li>The CLI suggests <code>touch app/index.jsx</code>, even if <code>app/index.tsx</code> exists.</li> <li>Routes defined in the <code>app/</code> directory (e.g., <code>app/index.tsx</code>, <code>app/_layout.tsx</code>) are ignored.</li> <li>No specific error messages may appear in the terminal, making debugging challenging.</li> <li>Clearing the cache (<code>npx expo start --clear</code>) or reinstalling dependencies doesn't resolve the issue unless <code>react-native-dotenv</code> is removed.</li> </ul>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#how-to-fix-the-issue","title":"How to Fix the Issue","text":"<p>To restore your app's functionality, you need to remove <code>react-native-dotenv</code> and switch to a compatible method for managing environment variables. Follow these steps:</p> <p>1. Uninstall <code>react-native-dotenv</code>:</p> <pre><code>npm uninstall react-native-dotenv\n</code></pre> <p>2. Remove the Babel Plugin:</p> <p>Update <code>babel.config.js</code> to remove the <code>react-native-dotenv</code> plugin:</p> <pre><code>module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\"babel-preset-expo\"],\n    plugins: [],\n  };\n};\n</code></pre> <p>3. Clear Cache:</p> <p>Clear the Metro bundler cache to ensure no stale configurations remain:</p> <pre><code>npx expo start --clear\n</code></pre> <p>4. Verify <code>app/</code> Directory:</p> <p>Ensure your <code>app/</code> directory contains at least <code>index.tsx</code> and <code>_layout.tsx</code> (for Expo Router):</p> <pre><code>// app/_layout.tsx\nimport { Stack } from \"expo-router\";\n\nexport default function Layout() {\n  return &lt;Stack /&gt;;\n}\n</code></pre> <pre><code>// app/index.tsx\nimport { StyleSheet, Text, View } from \"react-native\";\n\nexport default function Index() {\n  return (\n    &lt;View style={styles.container}&gt;\n      &lt;View style={styles.main}&gt;\n        &lt;Text style={styles.title}&gt;Hello World&lt;/Text&gt;\n        &lt;Text style={styles.subtitle}&gt;This is the first page of your app.&lt;/Text&gt;\n      &lt;/View&gt;\n    &lt;/View&gt;\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: \"center\",\n    padding: 24,\n  },\n  main: {\n    flex: 1,\n    justifyContent: \"center\",\n    maxWidth: 960,\n    marginHorizontal: \"auto\",\n  },\n  title: {\n    fontSize: 64,\n    fontWeight: \"bold\",\n  },\n  subtitle: {\n    fontSize: 36,\n    color: \"#38434D\",\n  },\n});\n</code></pre> <p>5. Verify <code>app.json</code>:</p> <p>Ensure the entry point is set correctly for Expo Router:</p> <pre><code>{\n  \"expo\": {\n    \"name\": \"my-app\",\n    \"slug\": \"my-app\",\n    \"entryPoint\": \"node_modules/expo-router/entry\"\n  }\n}\n</code></pre> <p>6. Test the App:</p> <p>Run the app to confirm that <code>app/index.tsx</code> loads correctly:</p> <pre><code>npx expo start --clear\n</code></pre>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#recommended-alternative-expos-built-in-environment-variable-support","title":"Recommended Alternative: Expo's Built-in Environment Variable Support","text":"<p>Expo provides a native, robust solution for managing environment variables that is fully compatible with Expo Router. This is the recommended approach for most Expo projects, especially those using SDK 49+.</p>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#setup-steps","title":"Setup Steps","text":"<p>1. Create a <code>.env</code> File:</p> <p>In your project root, create a <code>.env</code> file with variables prefixed with <code>EXPO_PUBLIC_</code> (for public variables):</p> <pre><code>EXPO_PUBLIC_API_URL=https://example.com\nEXPO_PUBLIC_API_KEY=1234567890abcdef\nEXPO_PUBLIC_SUPABASE_URL=https://udzpsgcefqhwlbgahoae.supabase.co\nEXPO_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\n</code></pre> <ul> <li>The <code>EXPO_PUBLIC_</code> prefix ensures variables are safely included in the app bundle.</li> <li>Add <code>.env</code> to <code>.gitignore</code> for security, especially for sensitive data.</li> </ul> <p>2. Access Variables in Code:</p> <p>Update your <code>app/index.tsx</code> to use <code>process.env</code>:</p> <pre><code>import { StyleSheet, Text, View } from \"react-native\";\n\nexport default function Index() {\n  const apiUrl = process.env.EXPO_PUBLIC_API_URL;\n  const apiKey = process.env.EXPO_PUBLIC_API_KEY;\n  const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL;\n  const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY;\n\n  return (\n    &lt;View style={styles.container}&gt;\n      &lt;View style={styles.main}&gt;\n        &lt;Text style={styles.title}&gt;Hello World&lt;/Text&gt;\n        &lt;Text style={styles.subtitle}&gt;This is the first page of your app.&lt;/Text&gt;\n        &lt;Text&gt;API_URL: {apiUrl}&lt;/Text&gt;\n        &lt;Text&gt;API_KEY: {apiKey}&lt;/Text&gt;\n        &lt;Text&gt;SUPABASE_URL: {supabaseUrl}&lt;/Text&gt;\n        &lt;Text&gt;SUPABASE_ANON_KEY: {supabaseAnonKey}&lt;/Text&gt;\n      &lt;/View&gt;\n    &lt;/View&gt;\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: \"center\",\n    padding: 24,\n  },\n  main: {\n    flex: 1,\n    justifyContent: \"center\",\n    maxWidth: 960,\n    marginHorizontal: \"auto\",\n  },\n  title: {\n    fontSize: 64,\n    fontWeight: \"bold\",\n  },\n  subtitle: {\n    fontSize: 36,\n    color: \"#38434D\",\n  },\n});\n</code></pre> <p>3. Add TypeScript Support (if using TypeScript):</p> <p>Update <code>env.d.ts</code> to include type definitions for <code>process.env</code>:</p> <pre><code>declare namespace NodeJS {\n  interface ProcessEnv {\n    EXPO_PUBLIC_API_URL: string;\n    EXPO_PUBLIC_API_KEY: string;\n    EXPO_PUBLIC_SUPABASE_URL: string;\n    EXPO_PUBLIC_SUPABASE_ANON_KEY: string;\n  }\n}\n</code></pre> <p>4. Test the App:</p> <p>Run the app to verify that environment variables load correctly:</p> <pre><code>npx expo start --clear\n</code></pre> <p>5. Handle Sensitive Variables:</p> <p>For sensitive variables (e.g., <code>SUPABASE_ANON_KEY</code>), use EAS Secrets for production builds:</p> <pre><code>eas secret:create --name SUPABASE_ANON_KEY --value your-key\n</code></pre> <p>Reference the secret in <code>eas.json</code>:</p> <pre><code>{\n  \"build\": {\n    \"production\": {\n      \"env\": {\n        \"SUPABASE_ANON_KEY\": \"$SUPABASE_ANON_KEY\"\n      }\n    }\n  }\n}\n</code></pre> <p>6. Support Multiple Environments:</p> <p>Create separate <code>.env</code> files for different environments (e.g., <code>.env.development</code>, <code>.env.production</code>). Expo CLI loads them based on the <code>--profile</code> flag in EAS builds:</p> <pre><code>eas build --profile production --platform all\n</code></pre>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#benefits-of-expos-built-in-support","title":"Benefits of Expo's Built-in Support","text":"<ul> <li>Compatibility: Works seamlessly with Expo Router and all Expo SDKs (49+).</li> <li>No Extra Dependencies: No need for additional libraries or Babel plugins.</li> <li>Security: <code>EXPO_PUBLIC_</code> variables are safe for bundling; sensitive vars can be managed via EAS Secrets.</li> <li>Flexibility: Supports multiple environments and dynamic loading via <code>.env</code> files.</li> <li>Type Safety: Integrates well with TypeScript via <code>env.d.ts</code>.</li> </ul>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#other-alternatives","title":"Other Alternatives","text":"<p>If you need a different approach, consider these libraries, but test for compatibility with Expo Router:</p> <p>react-native-config:</p> <ul> <li>Actively maintained, reads <code>.env</code> files at runtime via native linking.</li> <li>Requires a development build or bare workflow for Expo.</li> <li>Example: <code>import Config from 'react-native-config'; const apiUrl = Config.API_URL;</code>.</li> <li>Caveat: May require additional setup for Expo managed workflow.</li> </ul> <p>react-native-ultimate-config:</p> <ul> <li>A fork of <code>react-native-config</code> with improved features.</li> <li>Similar setup and caveats.</li> </ul> <p>Manual <code>app.json</code> Extras:</p> <ul> <li>Add static variables to <code>app.json</code>:   <pre><code>{\n  \"expo\": {\n    \"extra\": {\n      \"API_URL\": \"https://example.com\"\n    }\n  }\n}\n</code></pre></li> <li>Access: <code>import Constants from 'expo-constants'; const apiUrl = Constants.expoConfig?.extra?.API_URL;</code>.</li> <li>Drawback: Requires rebuild for changes; not ideal for sensitive data.</li> </ul>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#best-practices","title":"Best Practices","text":"<ul> <li>Use Expo's Built-in Support: It's the simplest and most reliable option for Expo Router projects.</li> <li>Secure Sensitive Data: Use EAS Secrets for API keys and other sensitive variables in production.</li> <li>Clear Cache Regularly: Run <code>npx expo start --clear</code> after configuration changes to avoid stale Metro bundler issues.</li> <li>Test Incrementally: When adding new libraries, test after each change to catch compatibility issues early.</li> <li>Check Expo SDK Version: Ensure your SDK (e.g., 51) supports the latest features. Check <code>package.json</code> or <code>app.json</code>.</li> </ul>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#conclusion","title":"Conclusion","text":"<p>The incompatibility between <code>react-native-dotenv</code> and Expo Router arises from the former's Babel plugin overwriting critical environment variables needed for routing, causing Expo to fail to load routes like <code>app/index.tsx</code>. By removing <code>react-native-dotenv</code> and adopting Expo's built-in environment variable support, you can manage variables effectively while maintaining compatibility with Expo Router. This approach is lightweight, secure, and aligns with Expo's ecosystem, making it the best choice for modern Expo projects. For advanced needs, consider <code>react-native-config</code> or EAS Secrets, but always test for compatibility with your specific setup.</p> <p>For more details, refer to the Expo Environment Variables Guide and Expo Router Documentation.</p>","tags":["react-native-dotenv"]},{"location":"blog/2025/12/18/why-react-native-dotenv-is-incompatible-with-expo-router/#reference","title":"Reference","text":"<ul> <li>github.com, react-native-dotenv: Incompatible with expo-router #501</li> <li>docs.expo.dev, Create your first app</li> </ul>","tags":["react-native-dotenv"]},{"location":"reactnative/expo-cli/","title":"Expo CLI","text":""},{"location":"reactnative/expo-cli/#install-expo-cli-optional-but-recommended-for-beginners","title":"Install Expo CLI (Optional but recommended for beginners)","text":"<p>Expo is a framework and platform for universal React applications. It simplifies the setup and development process, especially for beginners.</p> Example <ul> <li> <p>Install Expo CLI globally:</p> <p>WARNING: The legacy expo-cli does not support Node +17. Migrate to the new local Expo CLI:</p> <pre><code>npm install -g expo-cli\n</code></pre> </li> <li> <p>Create a New Expo Project</p> <pre><code># Create a new project using Expo CLI:\nexpo init my-new-project\n</code></pre> <p>Follow the prompts to choose a template. For a basic setup, the \u201cblank\u201d template is a good choice.</p> </li> <li> <p>Navigate to your project directory:</p> <pre><code>cd my-new-project\n</code></pre> </li> <li> <p>Start the development server:</p> <pre><code>expo start\n</code></pre> <p>This will start the Expo development server and open the Expo DevTools in your browser.</p> </li> </ul> Danger <pre><code>sudo npm install -g expo-cli\n</code></pre> <p>WARNING: The legacy expo-cli does not support Node +17. Migrate to the new local Expo CLI: https://blog.expo.dev/the-new-expo-cli-f4250d8e3421.</p> <p>(node:605277) [DEP0040] DeprecationWarning: The <code>punycode</code> module is deprecated. Please use a userland alternative instead. (Use <code>node --trace-deprecation ...</code> to show where the warning was created) \"help\" is not an expo command. See \"expo --help\" for the full list of commands.</p> Success <p>As of the latest updates, the <code>create-expo-app</code> tool, like other tools in the JavaScript ecosystem, is compatible with a range of Node.js versions. However, it's always a good practice to use a stable and supported Node.js version to avoid compatibility issues.</p> <p>Supported Node.js Versions for <code>create-expo-app</code></p> <ol> <li> <p>LTS (Long-Term Support) Versions:</p> <p><code>create-expo-app</code> generally supports Node.js LTS versions. LTS versions are recommended for stability and compatibility with various tools. As of now, the commonly supported LTS versions are:</p> <ul> <li>Node.js 18.x (Gallium): This is the current LTS release.</li> <li>Node.js 16.x (Fermium): This was the previous LTS version.</li> </ul> </li> <li> <p>Current Stable Version:</p> <p>While LTS versions are preferred, <code>create-expo-app</code> might also support the most recent stable Node.js versions. However, using the latest release (current version) might sometimes lead to unexpected issues if the tool or its dependencies are not yet fully compatible.</p> </li> </ol> <p>Recommendations</p> <ul> <li> <p>Use Node.js LTS Versions:</p> <p>For maximum compatibility and stability, use the current LTS version of Node.js. As of the latest guidance, Node.js 18.x is the recommended version.</p> </li> <li> <p>Verify Compatibility:</p> <p>Always check the Expo documentation or the Expo CLI GitHub repository for any specific version requirements or known issues related to Node.js versions.</p> </li> </ul>"},{"location":"reactnative/expo-cli/#how-to-manage-nodejs-versions","title":"How to Manage Node.js Versions","text":"<p>To manage and switch between different Node.js versions, you can use Node Version Manager (nvm):</p> <ol> <li> <p>Install <code>nvm</code> (if not already installed):</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash\n</code></pre> <p>Then load <code>nvm</code>:</p> <pre><code>source ~/.nvm/nvm.sh\n</code></pre> </li> <li> <p>Install and Use a Specific Node.js Version:</p> <pre><code>nvm install 18\nnvm use 18\n</code></pre> <p>Replace <code>18</code> with the desired version number.</p> </li> <li> <p>Check Installed Node.js Versions:</p> <pre><code>nvm ls\n</code></pre> </li> </ol>"},{"location":"reactnative/expo-cli/#steps-to-create-an-expo-app","title":"Steps to Create an Expo App","text":"<ol> <li> <p>Ensure Node.js Version: Verify you are using a compatible Node.js version:</p> <pre><code>node -v\n</code></pre> </li> <li> <p>Create a New Expo Project using create-expo-app:</p> <pre><code>npx create-expo-app MyNewApp\n</code></pre> </li> </ol>"},{"location":"reactnative/expo-cli/#running-an-expo-project","title":"Running an Expo Project","text":"<p>If you used <code>npx</code> to create an Expo project using <code>create-expo-app</code> or a similar command, follow these steps:</p> <ol> <li> <p>Navigate to Your Project Directory</p> <pre><code>cd MyNewApp\n</code></pre> <p>Replace <code>MyNewApp</code> with your project's directory name.</p> </li> <li> <p>Start the Expo Development Server</p> <p>Start the Expo development server by running:</p> <pre><code>npm start\n</code></pre> <p>or</p> <pre><code>npx expo start\n</code></pre> <p>This will start the Expo development server and open the Expo DevTools in your browser. You will see a QR code that you can scan with the Expo Go app to view your project on your mobile device.</p> </li> </ol>"},{"location":"reactnative/expo-cli/#set-up-a-development-environment-without-expo-optional","title":"Set Up a Development Environment <code>Without Expo</code> (Optional)","text":"<p>If you prefer not to use Expo and want more control, you can set up a React Native development environment directly:</p> For macOS and Linux: <ul> <li> <p>Install Watchman (a tool used for watching changes in the filesystem):</p> <pre><code>brew install watchman\n</code></pre> </li> </ul> <ul> <li> <p>Install the React Native CLI globally:</p> <pre><code>npm install -g react-native-cli\n</code></pre> </li> <li> <p>Create a New React Native Project</p> <pre><code># Create a new project using React Native CLI:\nnpx react-native init my-react-native-app\n\n# Navigate to the Project Directory\ncd my-react-native-app\n</code></pre> </li> <li> <p>Start the Development Server</p> <pre><code># Start the Metro bundler:\nnpx react-native start\n</code></pre> <p>In a new terminal window, run the app on iOS or Android:</p> <ul> <li> <p>iOS (macOS only):</p> <pre><code>npx react-native run-ios\n</code></pre> </li> <li> <p>Android:</p> <pre><code>npx react-native run-android\n</code></pre> </li> </ul> </li> </ul>"},{"location":"reactnative/overview/","title":"Overview","text":""},{"location":"reactnative/overview/#overview","title":"Overview","text":""},{"location":"reactnative/overview/#research-expo-react-native","title":"Research Expo (React Native)","text":"<p>Expo Official</p> <p></p> <p>expo create a new project</p> <pre><code>npx create-expo-app@latest\n\n# Start Expo APP\nnpx expo start\n\n# or This also works which eventually starts expo start\nnpm start\n</code></pre> Bug <pre><code>npm run andriod\n</code></pre> Method Android Studio Needed? Physical Device Support Emulator Support Notes Android SDK CLI No Yes Genymotion/SDK tools Manual setup, more control Expo CLI No Yes (Expo Go app) No (native modules) Easiest, but limited native support Community CLIs (Ignite) No Yes Yes Depends on CLI, check documentation <ul> <li>reactnative.dev, Get Started with React Native</li> </ul>"},{"location":"reactnative/overview/#common-issue-solved","title":"Common Issue Solved","text":"<p>uncaught error java lang exception incompatible sdk version expo sdk 53</p> <ul> <li>Upgrade Expo SDK</li> </ul> How to upgrade to the latest SDK version <p>1. Upgrade the Expo SDK</p> <p>Install the new version of the Expo package:</p> npm<pre><code># Install latest\n- npx expo install expo@latest\n\n# Install a specific SDK version (for example, SDK 52)\n- npx expo install expo@^52.0.0\n</code></pre> <p>2. Upgrade dependencies</p> <p>Upgrade all dependencies to match the installed SDK version.</p> bash<pre><code>npx expo install --fix\n</code></pre>"},{"location":"reactnative/topic/","title":"Topic","text":""},{"location":"reactnative/topic/#introduction","title":"Introduction","text":"<p>For a dating app, Firebase might be a strong choice, but a traditional database also has advantages depending on the features you're planning. Here\u2019s a tailored breakdown:</p> Firebase for a Dating App Pros:Cons: <ul> <li>Real-time Updates: Firebase's real-time database is great for instant messaging and live updates for matches, profile changes, etc.</li> <li>User Authentication: Firebase has built-in support for authentication via email, social logins (Google, Facebook), or phone numbers, which can speed up development.</li> <li>Push Notifications: Firebase Cloud Messaging (FCM) is useful for sending notifications (e.g., when a user receives a match or message).</li> <li>Storage: You can easily store user profile pictures and media using Firebase Storage.</li> <li>Scalability: Firebase can scale automatically with the growth of your user base without you worrying about server maintenance.</li> <li>Serverless Infrastructure: No need to manage your own servers, allowing you to focus on developing app features.</li> </ul> <ul> <li>Data Structure Complexity: A NoSQL database might make handling user relationships, preferences, and complex queries (e.g., search for matches based on criteria) harder to manage than a relational database.</li> <li>Pricing: As your user base grows, Firebase costs can increase, especially for data-heavy features like image storage or messaging.</li> </ul> Traditional Database for a Dating App (e.g., PostgreSQL, MySQL) Pros:Cons: <ul> <li>Relational Data: In a dating app, user profiles, preferences, and match algorithms often involve complex relationships, which are easier to handle in a relational database.</li> <li>Advanced Querying: SQL databases are more suited for sophisticated filtering and sorting (e.g., finding matches based on location, interests, etc.).</li> <li>Control: You have full control over the data structure, which might be better for implementing features like custom match algorithms, recommendation engines, and complex user data storage.</li> <li>Cost Control: Depending on your hosting, traditional databases may offer more predictable pricing as your app scales.</li> </ul> <ul> <li>More Work: You\u2019ll need to set up and maintain your backend infrastructure (user authentication, real-time messaging, etc.).</li> <li>Slower Initial Development: While Firebase allows for faster development, traditional setups require you to build more of the infrastructure yourself.</li> </ul>"},{"location":"reactnative/topic/#recommendation","title":"Recommendation:","text":"<ul> <li>Firebase: If you want a faster initial setup, plan to implement basic real-time features like chat, and prefer a managed backend, Firebase is a solid choice for the MVP of your dating app.</li> <li>Traditional Database: If your app\u2019s focus will involve complex search/matching logic, or you expect to scale rapidly with a large user base requiring advanced querying, a traditional database (like PostgreSQL) might be a better fit long-term.</li> </ul> <p>You could even use a hybrid approach: Firebase for real-time chat and notifications, and a traditional database for managing user profiles and relationships.</p> <p>Let me know if you need more insights based on specific features you\u2019re planning!</p>"},{"location":"reactnative/topic/#topic","title":"Topic","text":"<p>To become proficient in React Native, you'll need to master a range of topics, from the fundamentals to advanced features. Here\u2019s a roadmap of key areas to focus on:</p> <ol> <li> <p>Core React Native Concepts</p> <ul> <li>JSX: Learn how to write components using JSX syntax.</li> <li>Components (Functional and Class): Understand how to create and use components.</li> <li>State and Props: Master passing data between components using props and managing state within components.</li> <li>Lifecycle Methods: Familiarize yourself with lifecycle hooks (e.g., <code>useEffect</code>, <code>componentDidMount</code>).</li> <li>Hooks: Use React hooks like useState, useEffect, and advanced hooks (<code>useContext</code>, <code>useReducer</code>).</li> <li>Styling: Learn the StyleSheet and inline styling methods for designing UI components.</li> </ul> </li> <li> <p>Navigation</p> <ul> <li>React Navigation: Learn how to implement navigation using libraries like <code>react-navigation</code> for stacks, tabs, and drawer navigation.</li> <li>Deep Linking: Understand how to handle deep linking to route users to specific screens within the app.</li> </ul> </li> <li> <p>State Management</p> <ul> <li>Context API: Start with the built-in Context API for simple state management.</li> <li>Redux: Learn Redux for managing global state, actions, reducers, and how to integrate it with React Native.</li> <li>Redux Toolkit: Explore Redux Toolkit to simplify Redux setup.</li> <li>MobX: As an alternative to Redux, learn MobX for reactive state management.</li> </ul> </li> <li> <p>Networking &amp; API Integration</p> <ul> <li>Fetch &amp; Axios: Learn how to use <code>fetch()</code> or <code>Axios</code> for making API requests.</li> <li>REST API Integration: Understand how to connect React Native with REST APIs.</li> <li>GraphQL: Learn GraphQL if you\u2019re using GraphQL-based APIs.</li> <li>Handling Authentication: Implement login/signup flows using token-based authentication (JWT, OAuth, etc.).</li> </ul> </li> <li> <p>Handling Forms</p> <ul> <li>Form Handling: Learn to handle forms using controlled components and libraries like <code>formik</code> or <code>react-hook-form</code>.</li> <li>Validation: Implement form validation using <code>Yup</code> or custom validators.</li> </ul> </li> <li> <p>Storage &amp; Offline Capabilities</p> <ul> <li>AsyncStorage: Learn how to use AsyncStorage for local data storage.</li> <li>SQLite/Realm: Use local databases like SQLite or Realm for persistent data storage.</li> <li>Caching Data: Implement caching for API data to improve performance and offline capabilities.</li> </ul> </li> <li> <p>User Interface (UI)</p> <ul> <li>React Native UI Components: Learn how to use core components like <code>View</code>, <code>Text</code>, <code>Image</code>, <code>ScrollView</code>, <code>FlatList</code>, etc.</li> <li>Flexbox Layout: Master Flexbox for positioning and layout.</li> <li>Animations: Use Animated API and libraries like <code>react-native-reanimated</code> or <code>react-native-animatable</code> to create smooth animations.</li> <li>Gesture Handling: Understand gesture handling using <code>react-native-gesture-handler</code>.</li> </ul> </li> <li> <p>Third-Party Libraries</p> <ul> <li>UI Libraries: Familiarize yourself with UI libraries like React Native Paper, NativeBase, or Ant Design.</li> <li>Native Device Integration: Learn to integrate with native features using libraries like <code>react-native-camera</code>, <code>react-native-maps</code>, and <code>react-native-firebase</code>.</li> </ul> </li> <li> <p>Platform-Specific Features</p> <ul> <li>Platform-Specific Code: Understand how to write platform-specific code for iOS and Android using <code>Platform</code> and <code>Platform-specific extensions</code> (like <code>.ios.js</code> or <code>.android.js</code>).</li> <li>Permissions: Handle permissions for accessing the device's camera, location, etc., using libraries like <code>react-native-permissions</code>.</li> <li>Push Notifications: Set up push notifications using services like Firebase Cloud Messaging (FCM) or OneSignal.</li> </ul> </li> <li> <p>Performance Optimization</p> <ul> <li>Optimizing Rendering: Learn techniques to avoid unnecessary re-renders using <code>React.memo()</code>, <code>useCallback()</code>, <code>useMemo()</code>, etc.</li> <li>Lazy Loading &amp; Code Splitting: Implement lazy loading to split your code for faster initial load times.</li> <li>Image Optimization: Optimize images for performance, using tools like <code>react-native-fast-image</code>.</li> <li>Memory Management: Understand how to manage memory leaks, especially with asynchronous tasks.</li> </ul> </li> <li> <p>Debugging &amp; Testing</p> <ul> <li>Debugging Tools: Learn how to debug with React Native Debugger, Flipper, and Chrome Developer Tools.</li> <li>Unit Testing: Use testing frameworks like Jest and React Native Testing Library to write unit and integration tests.</li> <li>End-to-End Testing: Learn how to write E2E tests using tools like Detox.</li> </ul> </li> <li> <p>Versioning &amp; Deployment</p> <ul> <li>Version Control: Use Git for version control and learn how to manage branches, commits, and pull requests.</li> <li>Continuous Integration (CI): Set up CI/CD pipelines for automated testing and deployment using tools like GitHub Actions, CircleCI, or Bitrise.</li> <li>App Store Deployment: Learn the process of deploying your app to the Apple App Store (iOS) and Google Play Store (Android).</li> <li>Code Signing: Understand how to handle code signing for Android and iOS.</li> </ul> </li> <li> <p>TypeScript (Optional but Recommended)</p> <ul> <li>TypeScript: Learn TypeScript for type safety, which is becoming increasingly popular in React Native projects.</li> <li>Typed Components: Use TypeScript for better code maintenance and fewer runtime errors.</li> </ul> </li> <li> <p>Native Code (Optional for Advanced Development)</p> <ul> <li>Native Modules: Learn how to bridge native code (Java/Kotlin for Android and Swift/Objective-C for iOS) with React Native when needed.</li> <li>Custom Native Modules: Create custom native modules if your app needs functionality that isn't covered by existing React Native libraries.</li> </ul> </li> <li> <p>Building &amp; Packaging (for iOS &amp; Android)</p> <ul> <li>Android Studio/Xcode: Learn how to use Android Studio for Android development and Xcode for iOS development.</li> <li>Building APKs/IPAs: Understand how to build and package your app for release on both platforms.</li> <li>Code Signing and Profiles: Set up signing keys and profiles for iOS and Android to prepare for app distribution.</li> </ul> </li> </ol> Key Resources: <ul> <li>Official Docs: React Native Documentation</li> <li>React Navigation Docs: React Navigation</li> <li>React Native Testing Library: Testing Library</li> <li>GitHub Repos: Study open-source React Native projects to learn best practices.</li> </ul> Focus Areas for a Dating App: <p>Given that you're developing a dating app, you should pay special attention to:</p> <ul> <li>Real-time features (like messaging).</li> <li>Push notifications for alerts and messages.</li> <li>Efficient state management for handling user profiles and matches.</li> <li>Media handling (image uploads, profile pictures, etc.).</li> </ul> <p>Mastering these topics will help you build a solid, efficient, and scalable React Native app!</p>"},{"location":"reactnative/topic/#chat-functionality","title":"Chat Functionality","text":"<p>For real-time chat messaging in your React Native app, you have two main options to consider: Firebase and Django with WebSockets (using Django Channels). Each has its own advantages depending on your specific needs. Here's a breakdown to help you decide:</p> 1. Firebase (Firestore + Firebase Realtime Database)2. Django + WebSockets (Django Channels) <p>Firebase is a real-time, scalable, and managed backend solution that provides out-of-the-box real-time database functionality, which makes it a popular choice for chat apps.</p> <p>Advantages of Firebase:</p> <ul> <li>Real-time Database: Firebase Realtime Database and Firestore are built for real-time synchronization, which is ideal for chat features.</li> <li>Built-in Authentication: Firebase has easy-to-use authentication (Google, Facebook, Twitter, email, etc.), which is a huge plus for user management in a chat app.</li> <li>Push Notifications: Firebase Cloud Messaging (FCM) provides push notifications for new messages when the app is in the background.</li> <li>Scalability: Firebase scales easily without you needing to manage servers.</li> <li>Cross-Platform Support: You can use Firebase across iOS, Android, and the web seamlessly.</li> </ul> <p>Disadvantages of Firebase:</p> <ul> <li>Vendor Lock-in: You\u2019re tied to Firebase\u2019s ecosystem.</li> <li>Pricing: Firebase has a free tier, but real-time databases and scaling can become costly as your app grows.</li> <li>Limited Backend Customization: Firebase provides limited server-side logic customization compared to traditional backends.</li> </ul> <p>Best for:</p> <ul> <li>Fast, easy setup for real-time chat.</li> <li>When you don\u2019t want to manage a custom backend or server infrastructure.</li> <li>Small to medium-sized apps, especially if you plan on scaling quickly.</li> </ul> How to Implement Chat in Firebase: <ol> <li> <p>Set up Firebase in React Native: Install Firebase SDK and configure your app:</p> <pre><code>npm install --save @react-native-firebase/app @react-native-firebase/firestore\n</code></pre> </li> <li> <p>Real-time Chat Messaging using Firestore:</p> <p>You can use Firestore's real-time updates feature to listen for new messages and update the UI instantly.</p> <pre><code>import firestore from '@react-native-firebase/firestore';\n\n// To send a message:\nconst sendMessage = async (chatRoomId, message) =&gt; {\nawait firestore()\n    .collection('ChatRooms')\n    .doc(chatRoomId)\n    .collection('Messages')\n    .add({\n    text: message,\n    createdAt: firestore.FieldValue.serverTimestamp(),\n    userId: 'user123', // Replace with actual user id\n    });\n};\n\n// To listen for new messages in real-time:\nconst listenForMessages = (chatRoomId) =&gt; {\nreturn firestore()\n    .collection('ChatRooms')\n    .doc(chatRoomId)\n    .collection('Messages')\n    .orderBy('createdAt')\n    .onSnapshot((querySnapshot) =&gt; {\n    const messages = querySnapshot.docs.map((doc) =&gt; doc.data());\n    console.log(messages); // Update your UI with new messages\n    });\n};\n</code></pre> </li> </ol> <p>If you're already using Django for your backend, implementing real-time chat with WebSockets via Django Channels can be a powerful solution.</p> <p>Advantages of Django with WebSockets:</p> <ul> <li>Full Control: You control the backend and can customize your chat features as much as needed.</li> <li>Existing API: If you already have a Django API for your app, it's easier to extend your existing setup to include real-time messaging.</li> <li>Cost Control: You host and manage your server, which can be more cost-effective for larger-scale apps.</li> <li>Custom Logic: You can implement more advanced custom logic server-side for chat, including AI features like message filters, moderation, and chat analytics.</li> <li>Security: Easier to control the security of the system, especially if you need to comply with specific regulations (GDPR, etc.).</li> </ul> <p>Disadvantages of Django with WebSockets:</p> <ul> <li>More Setup: It\u2019s more complex to set up compared to Firebase.</li> <li>Server Management: You need to manage your servers, including scaling WebSocket connections.</li> <li>No Push Notifications Built-in: You would need a separate service (e.g., Firebase or OneSignal) to handle push notifications.</li> </ul> <p>Best for:</p> <ul> <li>When you already have a Django backend and want full control over your messaging system.</li> <li>When you need more advanced, customizable real-time features.</li> <li>If you plan on implementing complex server-side logic.</li> </ul> How to Implement Chat Using Django + WebSockets: <ol> <li> <p>Set up Django Channels:</p> <p>As mentioned earlier, Django Channels enables WebSockets for real-time communication in Django.</p> </li> <li> <p>Create WebSocket Endpoints:</p> <p>Use Django Channels to handle WebSocket connections for each chat room and manage sending and receiving messages in real-time.</p> </li> <li> <p>Connect WebSockets in React Native:</p> <p>Use the WebSocket API in React Native to connect to your Django Channels WebSocket endpoint.</p> <pre><code>const ws = new WebSocket('ws://your-backend-url/ws/chat/chatroom123/');\n\nws.onopen = () =&gt; {\nconsole.log('WebSocket connected');\n};\n\nws.onmessage = (e) =&gt; {\nconst message = JSON.parse(e.data);\nconsole.log(message); // Update the chat UI with the new message\n};\n\nconst sendMessage = (message) =&gt; {\nws.send(JSON.stringify({\n    message: message,\n}));\n};\n</code></pre> </li> <li> <p>Push Notifications:</p> <p>Implement push notifications (e.g., Firebase Cloud Messaging) for notifying users about new messages.</p> </li> </ol> Key Considerations: <ul> <li> <p>Real-Time Updates: Both Firebase and Django Channels can handle real-time updates. Firebase provides this out-of-the-box, while Django Channels requires setting up WebSocket connections.</p> </li> <li> <p>Scalability: If you\u2019re building a large-scale app that needs to scale quickly, Firebase can handle scaling automatically. With Django, you\u2019ll need to manage server scaling manually.</p> </li> <li> <p>Cost: Firebase offers a free tier, but costs can rise quickly as your user base grows. Django hosting can be cheaper in the long run, but it requires more management.</p> </li> <li> <p>Ease of Use: Firebase is easier to set up for real-time features, especially if you're starting from scratch. Django Channels gives you more flexibility but comes with more complexity.</p> </li> </ul> Recommendation: <ul> <li> <p>For Fast Setup &amp; Scalability: If you want to quickly add real-time chat functionality and don\u2019t want to manage server infrastructure, Firebase is a great choice. It will help you scale easily as your app grows.</p> </li> <li> <p>For Full Control &amp; Flexibility: If you\u2019re already using Django and want full control over the backend logic, Django with Channels is ideal, especially for more complex chat features that require custom server-side handling.</p> </li> </ul> <p>Let me know which direction you're leaning toward, and I can provide more detailed steps based on your choice!</p>"},{"location":"reactnative/websocket/","title":"WebSocket","text":""},{"location":"reactnative/websocket/#introduction","title":"Introduction","text":"<p>WebSockets provide a solution to the limitations of HTTP when it comes to real-time, bidirectional communication. To understand why WebSockets are necessary and how they differ from HTTP, we need to explore both protocols in depth.</p>"},{"location":"reactnative/websocket/#1-what-is-http","title":"1. What is HTTP?","text":"<p>HTTP (Hypertext Transfer Protocol) is the foundation of communication on the web. It is a request-response protocol, which means that a client (like a web browser or mobile app) makes a request to the server, and the server responds with the data.</p> How HTTP Works: <ul> <li>Client-initiated: The client sends an HTTP request to the server, and the server responds with the requested data (e.g., HTML, JSON).</li> <li>One-way communication: Once the server responds, the connection is closed.</li> <li>Stateless: Each request is independent. The server does not retain any memory of previous requests.</li> </ul> Limitations of HTTP: <ul> <li>No real-time updates: If the client needs updated information (like new chat messages), it has to keep asking the server by sending new requests.</li> <li>Polling required for real-time applications: To achieve a \"real-time\" effect, HTTP often relies on polling, which involves sending frequent requests to the server (e.g., every second). This is inefficient because most of the time, the server responds with nothing new, wasting resources.</li> <li>Latency: Even with techniques like polling or long polling, there's often a noticeable delay between sending and receiving data.</li> </ul>"},{"location":"reactnative/websocket/#2-the-theory-behind-websockets","title":"2. The Theory Behind WebSockets","text":"<p>WebSockets were designed to overcome the limitations of HTTP by enabling full-duplex communication between a client and a server over a single, long-lived connection. They allow the server to push data to the client as soon as it's available, without the client needing to ask for updates repeatedly.</p> Key Concepts of WebSockets: <ul> <li>Full-duplex: WebSockets allow both the client and server to send messages to each other at any time. This is what \"bidirectional\" means: either side can initiate communication.</li> <li>Persistent connection: Unlike HTTP, WebSockets keep the connection open after the initial handshake, allowing continuous communication without the overhead of re-establishing a new connection.</li> <li>Low-latency communication: Because the connection is kept open, messages are sent and received almost instantly, making it suitable for real-time applications.</li> </ul> How WebSockets Work: <ol> <li> <p>Initial Handshake: WebSockets start as an HTTP connection. The client sends an HTTP request to initiate the WebSocket protocol, using a special header:</p> <pre><code>GET /chat HTTP/1.1\nHost: example.com\nUpgrade: websocket\nConnection: Upgrade\n</code></pre> <p>The <code>Upgrade: websocket</code> header tells the server that the client wants to switch from HTTP to WebSockets. If the server supports WebSockets, it responds with:</p> <pre><code>HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\n</code></pre> <p>Once this handshake is complete, the connection switches from HTTP to WebSocket, and the connection remains open.</p> </li> <li> <p>Message Frames: After the handshake, data is sent over the WebSocket in small units called frames. These frames can carry text, binary data, or control information.</p> <ul> <li>Text Frames: For sending messages in a text format (e.g., JSON).</li> <li>Binary Frames: For sending binary data (e.g., images, files).</li> <li>Ping/Pong Frames: Keep the connection alive by checking whether the other side is still connected.</li> </ul> </li> <li> <p>Real-Time Communication: Once the connection is established, both the client and server can send messages to each other without needing to re-establish a connection. This makes WebSockets ideal for real-time applications like chat, live notifications, stock updates, gaming, etc.</p> </li> </ol>"},{"location":"reactnative/websocket/#3-why-http-alone-cant-do-bidirectional-communication","title":"3. Why HTTP Alone Can't Do Bidirectional Communication","text":"<p>HTTP was designed for a request-response pattern. The inherent problem with HTTP for bidirectional communication is that it is unidirectional by nature:</p> <ul> <li>Client-driven: The client always initiates the request, and the server can only respond to the client\u2019s request. This means the server can't push data to the client unless the client asks for it.</li> <li>Connection overhead: Each time the client makes a request, it needs to establish a new connection, which is slow and inefficient for real-time communication.</li> <li>No event-driven communication: Since HTTP doesn't keep the connection open, there's no way for the server to notify the client of new events (e.g., new messages in a chat) without the client asking for updates.</li> </ul> <p>To simulate real-time communication over HTTP, developers use techniques like:</p> <ul> <li>Polling: The client repeatedly sends requests at regular intervals to check if there's new data (e.g., every second). This is inefficient and puts a heavy load on the server.</li> <li>Long Polling: The client sends a request, and the server holds the connection open until new data is available. The server responds once new data arrives, and the client immediately sends another request. This reduces the number of requests but still has latency issues.</li> <li>Server-Sent Events (SSE): This allows the server to push updates to the client over a single, one-way HTTP connection. While it solves some problems, it's still only one-way (server to client), not truly bidirectional.</li> </ul>"},{"location":"reactnative/websocket/#4-advantages-of-websockets-over-http-for-real-time-communication","title":"4. Advantages of WebSockets Over HTTP for Real-Time Communication","text":"<ul> <li>Bidirectional communication: Both client and server can send and receive data simultaneously, which makes WebSockets perfect for real-time applications like chat systems, live feeds, and multiplayer games.</li> <li>Reduced latency: WebSockets eliminate the need for repeated HTTP requests, reducing latency and improving the responsiveness of the app.</li> <li>Less overhead: After the initial WebSocket handshake, the connection remains open, so there's no need to establish new connections for each message, reducing the overhead associated with HTTP.</li> <li>Scalability: WebSockets can handle many open connections without overwhelming the server, making them scalable for real-time applications.</li> </ul>"},{"location":"reactnative/websocket/#5-when-to-use-websockets","title":"5. When to Use WebSockets","text":"<p>WebSockets are ideal when you need low-latency, real-time, bidirectional communication. Some common use cases include:</p> <ul> <li>Chat applications: Real-time messaging between users where both parties need to send and receive data instantly.</li> <li>Real-time notifications: Apps where the server needs to push updates to the client immediately (e.g., stock trading, sports scores).</li> <li>Collaborative apps: Real-time collaboration tools like Google Docs or whiteboard apps where multiple users work together in real time.</li> <li>Online multiplayer games: Games that require instant communication between players and the server.</li> <li>Live video/audio streaming: Where real-time feedback is essential.</li> </ul>"},{"location":"reactnative/websocket/#6-comparison-between-websockets-and-http-techniques","title":"6. Comparison Between WebSockets and HTTP Techniques","text":"Feature HTTP Polling/Long Polling Server-Sent Events (SSE) WebSockets Connection Type Multiple short-lived connections Single one-way connection Single bidirectional connection Communication Client to server Server to client only Full-duplex (both directions) Latency High latency Medium latency Low latency Overhead High (many requests) Medium (fewer requests) Low (persistent connection) Scalability Limited Limited Scalable (many open connections) Use Cases Simple polling needs Push notifications, updates Real-time chat, gaming, etc."},{"location":"reactnative/websocket/#7-potential-challenges-with-websockets","title":"7. Potential Challenges with WebSockets","text":"<ul> <li>Connection Management: You need to manage open WebSocket connections carefully, especially in large-scale applications.</li> <li>Load Balancing: WebSocket connections are long-lived, so load balancing WebSocket traffic can be more challenging than HTTP requests.</li> <li>Security: WebSockets require careful attention to security, such as handling authentication, protecting against attacks like cross-site WebSocket hijacking, and ensuring SSL/TLS encryption.</li> </ul>"},{"location":"reactnative/websocket/#conclusion","title":"Conclusion:","text":"<ul> <li>HTTP is great for traditional web communication where the client initiates requests and the server responds with the requested data. But it is inefficient for real-time, bidirectional communication.</li> <li>WebSockets solve this problem by providing a persistent, full-duplex connection that allows both the server and the client to communicate in real-time without the need for constant reconnections.</li> </ul> <p>For applications like real-time chat, notifications, or collaborative apps, WebSockets are the most efficient and performant solution compared to using HTTP with polling or other techniques.</p>"},{"location":"reactnative/websocket/#who-developed-web-socket","title":"Who developed web socket?","text":"<p>WebSockets were developed by Ian Hickson, a former member of the Google Chrome team and a key contributor to many web standards, including HTML5. WebSockets were initially proposed as part of the HTML5 specification and were later separated into their own specification by the Internet Engineering Task Force (IETF) and the World Wide Web Consortium (W3C).</p> <p>Timeline of WebSocket Development:</p> <ol> <li> <p>Initial Proposal (2008-2009): WebSockets were first proposed by Ian Hickson as part of the HTML5 specification, recognizing the need for a real-time, bidirectional communication protocol to overcome the limitations of HTTP.</p> </li> <li> <p>Standardization:</p> <ul> <li>The IETF (Internet Engineering Task Force) took over the protocol's development and defined it in RFC 6455 in 2011. This document officially specifies the WebSocket protocol.</li> <li>Meanwhile, the W3C (World Wide Web Consortium) developed the API specification for WebSockets, which is now part of the broader HTML5 specification.</li> </ul> </li> <li> <p>Adoption: Major web browsers like Google Chrome, Mozilla Firefox, and Safari began supporting WebSockets around 2010-2011, making it a widely accepted standard for real-time web applications.</p> </li> </ol> <p>Since then, WebSockets have become a fundamental tool for building modern, real-time web applications such as chat systems, live updates, and multiplayer games.</p>"},{"location":"reactnative/websocket/#websockets-usage","title":"WebSockets Usage:","text":"<p>Yes, WebSockets are available in most modern programming languages and frameworks, thanks to their standardized protocol (RFC 6455). Since WebSockets are a protocol for bidirectional communication, language-specific libraries or frameworks handle the implementation, making it easy to use WebSockets across different platforms.</p> JavaScriptNode.js2. Python3. PHP <ul> <li>Client-side: WebSocket support is built into all modern browsers. You can directly use the <code>WebSocket</code> API.</li> </ul> <pre><code>const socket = new WebSocket('ws://example.com/socket');\nsocket.onmessage = (event) =&gt; console.log(event.data);\n</code></pre> <ul> <li>Server-side: In Node.js, WebSocket support is provided by libraries like <code>ws</code>, <code>Socket.IO</code>, and <code>uWebSockets.js</code>.</li> </ul> <pre><code>const WebSocket = require('ws');\nconst server = new WebSocket.Server({ port: 8080 });\nserver.on('connection', (ws) =&gt; {\n    ws.on('message', (message) =&gt; console.log(message));\n});\n</code></pre> <ul> <li> <p>Libraries: WebSocket libraries like <code>websockets</code>, <code>Socket.IO</code> (via <code>python-socketio</code>), and <code>FastAPI</code> (with native WebSocket support) are commonly used.</p> <pre><code>import asyncio\nimport websockets\n\nasync def echo(websocket, path):\n    async for message in websocket:\n        await websocket.send(message)\n\nstart_server = websockets.serve(echo, \"localhost\", 8765)\nasyncio.get_event_loop().run_until_complete(start_server)\nasyncio.get_event_loop().run_forever()\n</code></pre> </li> </ul> <ul> <li> <p>Libraries: <code>Ratchet</code>, <code>Socket.IO</code> PHP, and <code>Workerman</code> provide WebSocket functionality.\"</p> <pre><code>use Ratchet\\MessageComponentInterface;\nuse Ratchet\\ConnectionInterface;\n\nclass WebSocketServer implements MessageComponentInterface {\n    public function onMessage(ConnectionInterface $from, $msg) {\n        foreach ($this-&gt;clients as $client) {\n            $client-&gt;send($msg);\n        }\n    }\n}\n</code></pre> </li> </ul> <p>WebSockets are widely supported across nearly all programming languages. Each language offers its own set of libraries or frameworks to handle WebSocket connections, making it easy to implement real-time, bidirectional communication in a variety of environments.</p>"},{"location":"reactnative/expo/overview/","title":"Overview","text":""},{"location":"reactnative/expo/overview/#overview","title":"Overview","text":""},{"location":"reactnative/expo/overview/#visual-diagram-babel-bundler-workflow","title":"\ud83d\udd04 Visual Diagram: Babel + Bundler Workflow","text":"<pre><code>                     \ud83d\udd3d You write code\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \ud83d\udcc1 Your Source Files                                                        \u2502\n\u2502 \u251c\u2500\u2500 App.jsx                (JSX)                                            \u2502\n\u2502 \u251c\u2500\u2500 utils.js               (ES6+)                                           \u2502\n\u2502 \u251c\u2500\u2500 styles.css             (CSS)                                            \u2502\n\u2502 \u251c\u2500\u2500 logo.png               (Image)                                          \u2502\n\u2502 \u2514\u2500\u2500 index.html             (HTML)                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n          \ud83d\udd04 Babel (Compiler / Transpiler) \u2014 ONLY handles JS/JSX/TS\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 Babel reads .jsx, .js, .ts files and transpiles them:          \u2502\n   \u2502                                                                \u2502\n   \u2502    App.jsx \u2192 React.createElement(...)                         \u2502\n   \u2502    utils.js (ES6) \u2192 var, function, etc.                        \u2502\n   \u2502                                                                \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n       \ud83d\udce6 Bundler (Webpack, Vite, Parcel, etc.) \u2014 Handles entire project\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 Bundler does:                                                  \u2502\n   \u2502                                                                \u2502\n   \u2502  \u2705 Resolves imports                                           \u2502\n   \u2502     import React from 'react';                                 \u2502\n   \u2502                                                                \u2502\n   \u2502  \u2705 Handles assets:                                            \u2502\n   \u2502     import './styles.css';                                     \u2502\n   \u2502     import logo from './logo.png';                             \u2502\n   \u2502                                                                \u2502\n   \u2502  \u2705 Tree-shaking (removes unused code)                         \u2502\n   \u2502  \u2705 Code splitting                                             \u2502\n   \u2502  \u2705 Minification                                               \u2502\n   \u2502  \u2705 Hot Reload (in dev)                                        \u2502\n   \u2502                                                                \u2502\n   \u2502 All code and assets \u2192 bundled into optimized files             \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n         \ud83d\ude80 Final Output Sent to Browser (or deployed to production)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dist/ (output folder)                                                       \u2502\n\u2502 \u251c\u2500\u2500 index.html                \u2192 entry HTML                                  \u2502\n\u2502 \u251c\u2500\u2500 bundle.js                 \u2192 all JS code combined + transpiled           \u2502\n\u2502 \u251c\u2500\u2500 style.css                 \u2192 combined styles                             \u2502\n\u2502 \u251c\u2500\u2500 logo-optimized.png        \u2192 compressed asset                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n             \ud83d\udda5\ufe0f Browser runs final optimized bundle (no JSX/ES6 anymore)\n</code></pre>"},{"location":"reactnative/expo/overview/#key-concepts-visually-summarized","title":"\ud83e\udde0 Key Concepts Visually Summarized","text":"<pre><code>[ Your Code ]\n     \u2502\n     \u25bc\n[ Babel ]\n(Transpiles JSX &amp; modern JS)\n     \u2502\n     \u25bc\n[ Bundler ]\n(Packages everything together)\n     \u2502\n     \u25bc\n[ Final Optimized Output ]\n(Sent to the browser)\n</code></pre>"},{"location":"reactnative/expo/overview/#real-world-example-react-component-flow","title":"\ud83c\udfaf Real-World Example: React Component Flow","text":"<p>You write:</p> <pre><code>// App.jsx\nimport \"./styles.css\";\nconst App = () =&gt; &lt;h1&gt;Hello&lt;/h1&gt;;\n</code></pre> <p>Babel converts:</p> <pre><code>const App = () =&gt; React.createElement(\"h1\", null, \"Hello\");\n</code></pre> <p>Bundler:</p> <ul> <li>Resolves imports</li> <li>Includes <code>styles.css</code> and bundles it</li> <li>Packs everything into <code>bundle.js</code> and <code>style.css</code></li> </ul>"},{"location":"reactnative/statemanagement/overview/","title":"Overview","text":""},{"location":"reactnative/statemanagement/overview/#overview","title":"Overview","text":"<p>State management might sound like a technical term reserved for back-end systems, but it's incredibly relevant to front-end mobile development.</p> <p>Essentially, \"state\" in a React Native application refers to the data that determines the rendering and behavior of your components.</p> <p>When a user interacts with your app\u2014perhaps toggling a switch or filling out a form\u2014the app's state changes, and these changes are often reflected in the UI. The management of this state, especially as your application scales, can become a complex task.</p> <p>An introduction to Redux, explaining its core principles, such as actions, reducers, and the store.</p> <p>Advanced topics like handling asynchronous actions and incorporating middleware into your Redux setup.</p>"},{"location":"reactnative/statemanagement/overview/#managing-state-in-react-native","title":"Managing State in React Native","text":"<p>In any interactive application, the state is the linchpin that holds everything together. It's the variable data that dictates the app's behavior at any given moment. Whether you're checking the latest social media posts, making a reservation at a restaurant, or tracking your fitness goals, the 'state' of the application reflects what you see and can do on your device's screen. In React Native, understanding how to manage state effectively is crucial for developing sophisticated, reliable apps.</p> <p>State management is about more than just keeping track of values within your application. It's about architecting your application in a way that makes it scalable, maintainable, and understandable. As your application grows in complexity, managing state becomes a critical task that can determine the overall success and quality of your app.</p>"},{"location":"reactnative/statemanagement/overview/#local-state-vs-global-state","title":"Local State vs. Global State","text":"<p>State can be divided into two main categories:</p> <ol> <li> <p>Local State:</p> <p>This refers to state variables that belong to a specific component and aren't shared elsewhere. For example, a single checkbox or a toggle button within a component might have a local state that controls whether it's checked or not.</p> </li> <li> <p>Global State:</p> <p>This encompasses data that is shared across multiple parts of your app. For example, user authentication details, theme settings, or cached data from a network request would be part of the global state.</p> </li> </ol> <p>React Native provides mechanisms to handle both local and global state, though the complexity of managing these can differ significantly.</p>"},{"location":"reactnative/statemanagement/overview/#managing-global-state","title":"Managing Global State","text":"<p>For managing global state, you have a variety of options, including but not limited to:</p> <ol> <li> <p>React Context: This built-in React feature allows you to share state without having to pass props down through intermediate components.</p> </li> <li> <p>Redux: This is a third-party library that offers a predictable state container for JavaScript applications.</p> </li> <li> <p>MobX: Another third-party library that allows state management through observables.</p> </li> <li> <p>Apollo Client: If your app relies heavily on GraphQL, Apollo Client has built-in state management features designed to work well with GraphQL data.</p> </li> </ol>"},{"location":"reactnative/statemanagement/overview/#redux-fundamentals","title":"Redux Fundamentals","text":""},{"location":"reactnative/statemanagement/overview/#reference","title":"Reference","text":"<ul> <li>Mastering React Native By Cybellium Ltd</li> </ul>"},{"location":"reactnative/statemanagement/redux-fundamental/","title":"Redux Fundamental","text":""},{"location":"reactnative/statemanagement/redux-fundamental/#redux-fundamentals","title":"Redux Fundamentals","text":"<p>If you're diving into the world of React Native, you've probably heard the term \"Redux\" thrown around quite a bit. Redux is a popular state management library often used with React Native and React, although it's not limited to these libraries. It offers a predictable state container for your JavaScript apps, enabling you to manage the state in a consistent and straightforward manner. But what does it really mean to manage state \"predictably?\" Let's delve into the fundamentals of Redux to understand its role, how it works, and why it's often the go-to solution for complex React Native applications.</p>"},{"location":"reactnative/statemanagement/redux-fundamental/#core-principles-of-redux","title":"Core Principles of Redux","text":"<p>Redux operates on a few core principles that set it apart from other state management solutions:</p> <ol> <li> <p>Single Source of Truth:</p> <p>Redux uses a single store to keep the entire state of the application. This makes it easier to debug and inspect.</p> </li> <li> <p>State is Read-Only:</p> <p>The state in Redux is immutable. You do not change the state object directly but produce a new state object whenever a change is necessary.</p> </li> <li> <p>Changes are made with Pure Functions:</p> <p>In Redux, reducers are used to specify how the state changes in response to an action.</p> </li> </ol>"},{"location":"reactnative/statemanagement/redux-fundamental/#redux-terminology","title":"Redux Terminology","text":"<p>Before proceeding further, it's crucial to familiarize yourself with some of the terms commonly used in the Redux ecosystem:</p> <ol> <li> <p>Store: The central repository holding the state of the entire application.</p> </li> <li> <p>Action: A plain JavaScript object that describes what happened, usually triggered by user interactions or events.</p> </li> <li> <p>Reducer: A pure function that takes the current state and an action as arguments and returns a new state.</p> </li> <li> <p>Middleware: A higher-order function that sits between the dispatching of an action and the reducer. It is often used for logging, error reporting, or asynchronous operations.</p> </li> <li> <p>Dispatch: The process of sending an action to the reducer to update the state.</p> </li> <li> <p>Selector: A function that takes the Redux state as an argument and returns some part of it.</p> </li> </ol>"},{"location":"reactnative/statemanagement/redux-fundamental/#the-redux-cycle-actions-reducers-and-the-store","title":"The Redux Cycle: Actions, Reducers, and the Store","text":"<p>The core idea behind Redux is to maintain a predictable cycle where actions are dispatched, reducers handle these actions to produce a new state, and the store is updated with this new state.</p>"},{"location":"blog/archive/2025/","title":"2025","text":""}]}